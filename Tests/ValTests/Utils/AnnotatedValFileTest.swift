import Core
import Utils
import XCTest

extension Diagnostic {

  /// A test annotation that announces `self` should be expected.
  var expectation: TestAnnotation {
    TestAnnotation(
      in: site.file.url,
      atLine: site.first().line.number,
      parsing: "diagnostic " + message
    )
  }

}

extension XCTestCase {

  /// The effects of running the `processAndCheck` parameter to `checkAnnotatedValFiles`.
  fileprivate typealias ProcessingEffects = (
    /// Whether the processing completed without Val errors.
    ranToCompletion: Bool,
    /// Test failures generated by processing.
    testFailures: [XCTIssue],
    /// Val diagnostics generated by processing.
    diagnostics: DiagnosticSet
  )

  /// Applies `process` to each ".val" file in the test suite located at `suitePath` relative to
  /// `swiftFile` and reports XCTest failures where the effects of processing don't match the
  /// file's diagnostic annotation commands ("diagnostic", "expect-failure", and "expect-success").
  ///
  /// - Parameters:
  ///   - suitePath: a path relative to the `swiftFile`.
  ///   - swiftFile: the path of the file calling this function.
  ///   - process: applies some compilation phases to `file`, updating `diagnostics` with any
  ///     generated diagnostics. Throws an `Error` if any phases failed.
  func checkAnnotatedValFileDiagnostics(
    inSuiteAt suitePath: String,
    relativeTo swiftFile: StaticString = #filePath,
    _ process: (_ file: SourceFile, _ diagnostics: inout DiagnosticSet) throws -> Void
  ) throws {
    try checkAnnotatedValFiles(
      inSuiteAt: suitePath, relativeTo: swiftFile, checkingAnnotationCommands: [],
      { (file, annotationsToHandle, diagnostics) in
        assert(annotationsToHandle.isEmpty)
        try process(file, &diagnostics)
        return []
      }
    )
  }

  /// Applies `processAndCheck` to each ".val" file in the test suite located at `suitePath`
  /// relative to `swiftFile` along with the subset of that file's annotations whose commands match
  /// `checkedCommands`, and reports resulting XCTest failures, along with any additional failures
  /// where the effects of processing don't match the file's diagnostic annotation commands
  /// ("diagnostic", "expect-failure", and "expect-success").
  ///
  /// - Parameters:
  ///   - suitePath: a path relative to the `swiftFile`.
  ///   - swiftFile: the path of the file calling this function.
  ///   - checkedCommands: the annnotation commands to be validated by `processAndCheck`.
  ///   - processAndCheck: applies some compilation phases to `file`, updating `diagnostics`
  ///     with any generated diagnostics, then checks `annotationsToCheck` against the results,
  ///     returning corresponding test failures. Throws an `Error` if any phases failed.
  func checkAnnotatedValFiles(
    inSuiteAt suitePath: String,
    relativeTo swiftFile: StaticString = #filePath,
    checkingAnnotationCommands checkedCommands: Set<String> = [],
    _ processAndCheck: (
      _ file: SourceFile,
      _ annotationsToCheck: ArraySlice<TestAnnotation>,
      _ diagnostics: inout DiagnosticSet
    ) throws -> [XCTIssue]
  ) throws {
    let testCases = try testSuite(at: suitePath, relativeTo: swiftFile)
    for file in testCases {
      var annotations = TestAnnotation.parseAll(from: file)

      // Separate the annotations to be checked by default diagnostic annotation checking from
      // those to be checked by `processAndCheck`.
      let p = annotations.partition(by: { checkedCommands.contains($0.command) })
      let (diagnosticAnnotations, processingAnnotations) = (annotations[..<p], annotations[p...])

      var diagnostics = DiagnosticSet()
      let failures = XCTContext.runActivity(
        named: file.baseName,
        block: { activity in
          let completedProcessingTestFailures = try? processAndCheck(
            file, processingAnnotations, &diagnostics)

          return failuresToReport(
            effectsOfProcessing: (
              ranToCompletion: completedProcessingTestFailures != nil,
              testFailures: completedProcessingTestFailures ?? [],
              diagnostics: diagnostics
            ),
            unhandledAnnotations: diagnosticAnnotations)
        })

      for f in failures {
        record(f)
      }
    }
  }

  /// Returns the Val test cases in the suite at `path` relative to `swiftFile`.
  ///
  /// The suite is sought at `path` relative to `swiftFile`. If no such directory exists, the
  /// suite is sought at `path` relative to the root of the resource bundle associated with the
  /// current Swift module.
  fileprivate func testSuite(
    at path: String, relativeTo swiftFile: StaticString
  ) throws -> [SourceFile] {
    let suiteDirectoryRelativeToSwiftFile = URL(
      fileURLWithPath: path, relativeTo: URL(fileURLWithPath: String(swiftFile)))

    if suiteDirectoryRelativeToSwiftFile.hasDirectoryPath {
      return try sourceFiles(in: [suiteDirectoryRelativeToSwiftFile])
    } else {
      let s = Bundle.module.url(forResource: path, withExtension: nil)!
      return try sourceFiles(in: [s])
    }
  }

  /// Given the effects of processing and the annotations not specifically handled by
  /// `processAndCheck` above, returns the final set of test failures to be reported to XCTest.
  fileprivate func failuresToReport(
    effectsOfProcessing processing: ProcessingEffects,
    unhandledAnnotations: ArraySlice<TestAnnotation>
  ) -> [XCTIssue] {
    var testFailures = processing.testFailures

    var diagnosticsByExpectation = Dictionary(
      grouping: processing.diagnostics.elements, by: \.expectation)

    func fail(_ expectation: TestAnnotation, _ message: String) {
      testFailures.append(expectation.failure(message))
    }

    for a in unhandledAnnotations {
      switch a.command {
      case "diagnostic":
        if diagnosticsByExpectation[a]?.popLast() != nil {
        } else {
          fail(a, "missing expected diagnostic\(a.argument.map({": '\($0)'"}) ?? "")")
        }
      case "expect-failure":
        if processing.ranToCompletion {
          fail(a, "processing succeeded, but failure was expected")
        }
      case "expect-success":
        if !processing.ranToCompletion {
          fail(a, "processing failed, but success was expected")
        }
      default:
        fail(a, "unexpected test command: '\(a.command)'")
      }
    }

    testFailures += diagnosticsByExpectation.values.joined().lazy.map {
      XCTIssue(.error("unexpected diagnostic: '\($0.message)'", at: $0.site, notes: $0.notes))
    }
    return testFailures
  }

}
