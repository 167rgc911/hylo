view V {
  type X
  fun foo(x: X) -> X
}

// #!error@+1 conformance to 'V' requires a matching implementation of 'X'
type A: V {
}

type B<X>: V {
  fun foo(x: X) -> X { ret x }
}

type C: V {
  type X {}
  fun foo(x: X) -> X { ret x }
}

view U {
  type Y: V
  fun bar(y: Y, u: Self)
}

// #!error@+1 conformance to 'U' requires a matching implementation of 'Y'
type D: U {
}

// #!error@+1 type '$Y' does not conform to view 'V'
type E<Y>: U {
  fun bar(y: Y, u: E<Y>) {
  }
}

type F<Y where Y: V>: U {
  val x: Y::X
  fun bar(y: Y, u: F<Y>) {
    y.foo(x: x)
  }
}

type G: U {
  type Y = C
  fun bar(y: Y, u: G) {
    y.foo(x: C::X())
  }
}
