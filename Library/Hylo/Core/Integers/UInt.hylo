/// An unsigned integer value.
public type UInt {

  var value: Builtin.word

  memberwise init

  /// Creates an instance with value `0`.
  public init() {
    &self.value = Builtin.zeroinitializer_word()
  }

  /// Creates an instance with the same memory representation as `other`.
  public init(bit_pattern other: Int) {
    &self.value = other.value
  }

  /// Creates an instance with the same memory representation as `address`.
  public init(bit_pattern address: MemoryAddress) {
    &self.value = Builtin.ptrtoint_word(address.base)
  }

  /// Returns `true` if `self` is greater than `other`. Otherwise, returns `false`.
  public fun infix> (_ other: Self) -> Bool {
    Bool(value: Builtin.icmp_ugt_word(value, other.value))
  }

  /// Returns `true` if `self` is equal to `other`. Otherwise, returns `false`.
  public fun infix== (_ other: Self) -> Bool {
    Bool(value: Builtin.icmp_eq_word(value, other.value))
  }

  /// Returns `true` if `self` is not equal to `other`. Otherwise, returns `false`.
  public fun infix!= (_ other: Self) -> Bool {
    Bool(value: Builtin.icmp_ne_word(value, other.value))
  }

  /// Returns the bitwise AND of `self` and `other`.
  public fun infix& (_ other: Self) -> Self {
    UInt(value: Builtin.and_word(value, other.value))
  }

  /// Writes the bitwise AND of `self` and `other` to `self`.
  public fun infix&= (_ other: Self) inout {
    &self.value = Builtin.and_word(value, other.value)
  }

  /// Returns the bitwise OR of `self` and `other`.
  public fun infix| (_ other: Self) -> Self {
    UInt(value: Builtin.or_word(value, other.value))
  }

  /// Writes the bitwise OR of `self` and `other` to `self`.
  public fun infix|= (_ other: Self) inout {
    &self.value = Builtin.or_word(value, other.value)
  }

  /// Returns the bitwise XOR of `self` and `other`.
  public fun infix^ (_ other: Self) -> Self {
    UInt(value: Builtin.xor_word(value, other.value))
  }

  /// Writes the bitwise XOR of `self` and `other` to `self`.
  public fun infix^= (_ other: Self) inout {
    &self.value = Builtin.xor_word(value, other.value)
  }

  /// Returns the bitwise inverse of `self`.
  public fun prefix~ () -> Self {
    self ^ UInt(bit_pattern: -1)
  }

}

public conformance UInt: ExpressibleByIntegerLiteral {}

public conformance UInt: Deinitializable {}

public conformance UInt: Copyable {

  public fun copy() -> Self {
    UInt(value: value)
  }

}

public conformance UInt: BinaryInteger {

  public fun instance_bit_width() -> Int {
    Self.bit_width()
  }

  public fun signum() -> Int {
    Int(value: Builtin.zext_i1_word((self > UInt()).value))
  }

  public fun nonzero_bit_count() -> Int {
    Int(value: Builtin.ctpop_word(value))
  }

  public fun leading_zeros() -> Int {
    Int(value: Builtin.ctlz_word(value))
  }

  public fun trailing_zeros() -> Int {
    Int(value: Builtin.cttz_word(value))
  }

  public static fun is_signed() -> Bool {
    false
  }

}

public conformance UInt: FixedWidthInteger {

  public fun adding_reporting_overflow(_ other: Self) -> {partial_value: Self, overflow: Bool} {
    let r = Builtin.uadd_with_overflow_word(value, other.value)
    return (partial_value: UInt(value: r.0), overflow: Bool(value: r.1))
  }

  public fun subtracting_reporting_overflow(
    _ other: Self
  ) -> {partial_value: Self, overflow: Bool} {
    let r = Builtin.usub_with_overflow_word(value, other.value)
    return (partial_value: UInt(value: r.0), overflow: Bool(value: r.1))
  }

  public fun multiplied_reporting_overflow(
    by other: Self
  ) -> {partial_value: Self, overflow: Bool} {
    let r = Builtin.umul_with_overflow_word(value, other.value)
    return (partial_value: UInt(value: r.0), overflow: Bool(value: r.1))
  }

  public fun divided_reporting_overflow(by other: Self) -> {partial_value: Self, overflow: Bool} {
    if other == UInt() {
      return (partial_value: self.copy(), overflow: true)
    }
    return (partial_value: UInt(value: Builtin.udiv_word(value, other.value)), overflow: false)
  }

  public fun remainder_reporting_overflow(
    dividing_by other: Self
  ) -> {partial_value: Self, overflow: Bool} {
    if other == UInt() {
      return (partial_value: self.copy(), overflow: true)
    }
    return (partial_value: UInt(value: Builtin.urem_word(value, other.value)), overflow: false)
  }

  public static fun bit_width() -> Int {
    MemoryLayout<Builtin.word>.size() * 8
  }

  public static fun max() -> Self {
    ~UInt()
  }

  public static fun min() -> Self {
    0
  }

}
