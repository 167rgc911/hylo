/// An ordered, random-access collection.
public type Array<Element: Movable>: Deinitializable {

  /// The out-of-line storage of the array.
  var _storage: DynamicBuffer<Void, Element>

  /// The number of elements in the array.
  var _count: Int

  /// Creates a new, empty array.
  public init() {
    &_storage = .new()
    &_count = 0
  }

  /// The number of elements in the array.
  public fun count() -> Int {
    return _count.copy()
  }

  /// The number of elements that can be stored in the array before new storage must be allocated.
  public fun capacity() -> Int {
    return _storage.capacity()
  }

  /// Reserves enough space to store `n` elements
  public fun reserve_capacity(_ n: Int) {
    if n < capacity() { return }

    var new_capacity = max[1, capacity()].copy()
    while new_capacity < n {
      &new_capacity = capacity() + capacity()
    }

    var new_storage = DynamicBuffer<Void, Element>(
      capacity: new_capacity,
      initializing_header_with: fun (_ h: set Void) -> Void { &h = () })

    var i = 0
    var e = _storage.first_element_address()
    var f = new_storage.first_element_address()
    while i < count() {
      // TODO: This is currently blocked by #1003
      // f.unsafe_initialize_pointee( fun(_ x:set Element) -> Void {
      //   &x = e.unsafe[]
      // } )

      &e = e.advance(by: 1)
      &f = f.advance(by: 1)
    }

    &_storage = new_storage
  }

  /// Adds a new element at the end of the array.
  public fun append(from source: sink Element) {
    reserve_capacity(count() + 1)
    var p = _storage.first_element_address().advance(by: count())
    // TODO: This is currently blocked by #1006
    // p.unsafe_initialize_pointee(fun[sink let s = source] (_ x: set Element) -> Void {
    //   &x = s
    // })
  }

}

/*

// TODO: Make Array conform to Regular instead of Deinitializable once #1002 is fixed.
// Currently that issue prevents the copy() function below from compiling.
//
// Error is "type 'Element' does not conform to trait 'Movable'"

public conformance Array: Equatable {

  /// Returns `true` iff `other` has an equivalent value.
  public fun infix== (_ other: Self) -> Bool {
    // TODO
    return true
  }

}

public conformance Array: Copyable {
  /// Returns an equivalent instance.
  public fun copy() -> Self {
    // TODO
    .new()
  }
}

*/
