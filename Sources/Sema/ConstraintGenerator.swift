import AST
import Basic

/// A driver for constraint generation.
final class ConstraintGenerator: NodeWalker {

  init(context: AST.Context) {
    self.context = context
    super.init()

    // Create the internal visitor.
    self.exprVisitor = ExprConstraintVisitor(gen: self)
  }

  /// The AST context.
  unowned let context: AST.Context

  /// The constraint system generated by the pass.
  var system = ConstraintSystem()

  /// The visitor that realizes type declarations.
  fileprivate var declRealizer = DeclRealizer()

  /// The visitor that extracts constraints from the AST.
  fileprivate var exprVisitor: ExprConstraintVisitor!

  /// A FILO stack accumulating the function declarations we traversed up to the current node.
  fileprivate var funDeclStack: [AbstractFunDecl] = []

  /// The innermost declaration space in which the next expression will be visited.
  fileprivate var innermostSpace: DeclSpace?

  fileprivate typealias ExistentialKey = HashableBox<ValType, ReferenceHashWitness<ValType>>

  /// A mapping that keep tracks of the existential types that have been created.
  fileprivate var existentials: [ExistentialKey: ExistentialType] = [:]

  /// Realizes the semantic type expressed by a representation.
  ///
  /// A type representation can denote either  three kinds of types:
  /// - A fully concrete type. This denotes either a non-generic type (e.g., `Int`) or a generic
  ///   type that has been specialized (e.g., `Array<Int>`). In this case, the semantic type is
  ///   fully known and the method just returns the type to which the representation resolves.
  /// - An unspecialized generic type (e.g., `Array` without any specialization clause). This
  ///   requires to "open" the type to which the representation resolves (i.e., substitute its
  ///   generic parameters for fresh variables).
  /// - An existential type (e.g., `T` within the context of `fun foo<T>`). This denotes a type
  ///   that is not known statically, but for which we may assume some conformances.
  fileprivate func instanciate(_ type: ValType) -> ValType {
    if let param = type as? GenericParamType {
      // FIXME: A lot of magic will have to happen here to handle associated and dependent types.
      if let existential = existentials[HashableBox(param)] {
        return existential
      }

      let existential = context.existentialType()
      existentials[HashableBox(param)] = existential
      return existential
    }

    if type.props.contains(.hasTypeParams) {
      return type.opened
    }

    return type
  }

  // MARK: AST Walk

  public override func willVisit(_ decl: Decl) -> (shouldWalk: Bool, nodeBefore: Decl) {
    if let space = decl as? DeclSpace {
      innermostSpace = space
      if let funDecl = space as? AbstractFunDecl {
        funDeclStack.append(funDecl)
      }
    }

    if decl is FunParamDecl {
      // Parameters are visited via their function's realizer.
      return (true, decl)
    }

    return (decl.accept(declRealizer), decl)
  }

  public override func didVisit(_ decl: Decl) -> (shouldContinue: Bool, nodeAfter: Decl) {
    if let space = decl as? DeclSpace {
      innermostSpace = space.parentDeclSpace
      if space is AbstractFunDecl {
        funDeclStack.removeLast()
      }
    }

    if let binding = decl as? PatternBindingDecl {
      exprVisitor.visit(binding)
    }

    return (true, decl)
  }

  public override func willVisit(_ stmt: Stmt) -> (shouldWalk: Bool, nodeBefore: Stmt) {
    if let space = stmt as? DeclSpace {
      innermostSpace = space
    }
    return (true, stmt)
  }

  public override func didVisit(_ stmt: Stmt) -> (shouldContinue: Bool, nodeAfter: Stmt) {
    stmt.accept(exprVisitor)

    if let space = stmt as? AbstractFunDecl {
      innermostSpace = space.parentDeclSpace
    }

    return (true, stmt)
  }

  public override func didVisit(_ expr: Expr) -> (shouldContinue: Bool, nodeAfter: Expr) {
    // Perform some pre-processing on the expression, in particular to bind and/or desugar
    // declaration references that could not be resolved by the parser.
    let newExpr = expr.accept(ExprBinder(space: innermostSpace!))

    // Generate type constraints.
    newExpr.accept(exprVisitor)
    return (true, newExpr)
  }

  public override func willVisit(
    _ typeRepr: TypeRepr
  ) -> (shouldWalk: Bool, nodeBefore: TypeRepr) {
    typeRepr.realize(within: innermostSpace!)
    return (false, typeRepr)
  }

}

/// An AST visitor that realizes the type of a declaration.
fileprivate struct DeclRealizer: DeclVisitor {

  typealias DeclResult = Bool

  func visit(_ node: Module) -> Bool {
    return true
  }

  func visit(_ node: PatternBindingDecl) -> Bool {
    return true
  }

  func visit(_ node: VarDecl) -> Bool {
    return true
  }

  func visit(_ node: AbstractFunDecl) -> Bool {
    node.retSign?.realize(within: node)
    for param in node.params {
      _ = visit(param)
    }
    node.recomputeAppliedType()
    return true
  }

  func visit(_ node: FunDecl) -> Bool {
    visit(node as AbstractFunDecl)
  }

  func visit(_ node: CtorDecl) -> Bool {
    visit(node as AbstractFunDecl)
  }

  func visit(_ node: FunParamDecl) -> Bool {
    if let sign = node.sign {
      if let type = sign.realize(within: node.parentDeclSpace!) {
        node.type = type
      } else {
        node.type = node.type.context.unresolvedType
      }
    } else {
      node.type = TypeVar(context: node.type.context, node: node)
    }
    return true
  }

  func visit(_ node: AbstractNominalTypeDecl) -> Bool {
    assert(node.type is KindType)
    return true
  }

  func visit(_ node: ProductTypeDecl) -> Bool {
    assert(node.type is KindType)
    return true
  }

  func visit(_ node: ViewTypeDecl) -> Bool {
    assert(node.type is KindType)
    return true
  }

  func visit(_ node: GenericParamDecl) -> Bool {
    assert(node.type is GenericParamType)
    return true
  }

  func visit(_ node: TypeExtDecl) -> Bool {
    guard let type = node.extendedIdent.realize(within: node.parentDeclSpace!) else {
      // The diagnostic is emitted by the failed attempt to realize the base.
      node.state = .invalid
      return false
    }

    guard let decl = (type as? NominalType)?.decl else {
      type.context.report(.nonNominalExtension(type, range: node.extendedIdent.range))
      node.state = .invalid
      return false
    }

    node.state = .bound(decl)
    return true
  }

}

/// An AST visitor that generates type constraints for a statement or an expression.
fileprivate struct ExprConstraintVisitor: StmtVisitor, ExprVisitor {

  typealias StmtResult = Void
  typealias ExprResult = Void

  unowned let gen: ConstraintGenerator

  func visit(_ node: PatternBindingDecl) {
    // If the declaration has a signature, it as the authoritative type information.
    if let sign = node.sign,
       let signType = sign.realize(within: node.parentDeclSpace!)
    {
      gen.system.insert(
        EqualityConstraint(
          node.pattern.type, isEqualTo: gen.instanciate(signType),
          at: ConstraintLocator(node, .annotation)))

      // Since the actual type of the pattern if described by the signature, we can treat the
      // initializer as a mere assignment and only impose a subtyping constraint
      if let initializer = node.initializer {
        gen.system.insert(
          SubtypingConstraint(
            initializer.type, isSubtypeOf: node.pattern.type,
            at: ConstraintLocator(node, .assignment)))
      }
    } else if let initializer = node.initializer {
      // Since we could not infer the type of the pattern from a signature, we must infer it
      // directly from the initializer. We use an equality constraint to type the pattern as
      // closely as tightly as possible to the initializer.
      gen.system.insert(
        EqualityConstraint(
          node.pattern.type, isEqualTo: initializer.type,
          at: ConstraintLocator(node, .assignment)))
    }
  }

  func visit(_ node: BraceStmt) {
  }

  func visit(_ node: RetStmt) {
    guard let funDecl = gen.funDeclStack.last else { return }

    // Retrieve the expected return type.
    let retType: ValType
    if let sign = funDecl.retSign {
      precondition(sign.state != .parsed, "function signature should have been realized")
      retType = sign.state == .realized
        ? gen.instanciate(sign.type)
        : gen.context.unresolvedType
    } else {
      retType = gen.context.unitType
    }

    let valType = node.value?.type ?? gen.context.unitType
    gen.system.insert(
      SubtypingConstraint(
        valType, isSubtypeOf: retType,
        at: ConstraintLocator(node, .returnValue)))
  }

  func visit(_ node: IntLiteralExpr) {
    precondition(gen.context.stdlib != nil, "standard library is not loaded")

    let viewTypeDecl = gen.context.getTypeDecl(for: .ExpressibleByBuiltinIntLiteral)!
    gen.system.insert(
      ConformanceConstraint(
        node.type, conformsTo: viewTypeDecl.instanceType as! ViewType,
        at: ConstraintLocator(node)))
  }

  func visit(_ node: AssignExpr) {
    gen.system.insert(
      SubtypingConstraint(
        node.rvalue.type, isSubtypeOf: node.lvalue.type,
        at: ConstraintLocator(node, .assignment)))
  }

  func visit(_ node: CallExpr) {
    // Synthetize the type of a function from the call's arguments.
    var paramTypeElems: [TupleType.Elem] = []
    for arg in node.args {
      // The subtyping constraint handle cases where the argument is a subtype of the parameter.
      let paramType = TypeVar(context: gen.context, node: arg.value)
      gen.system.insert(
        SubtypingConstraint(
          arg.value.type, isSubtypeOf: paramType,
          at: ConstraintLocator(node, .application)))
      paramTypeElems.append(TupleType.Elem(label: arg.label, type: paramType))
    }

    let paramType = gen.context.tupleType(paramTypeElems)
    let funType = gen.context.funType(paramType: paramType, retType: node.type)
    gen.system.insert(
      EqualityConstraint(
        node.fun.type, isEqualTo: funType,
        at: ConstraintLocator(node.fun)))
  }

  func visit(_ node: UnresolvedDeclRefExpr) {
  }

  func visit(_ node: UnresolvedMemberExpr) {
    gen.system.insert(
      ValueMemberConstraint(
        node.base.type, hasValueMember: node.memberName, ofType: node.type,
        at: ConstraintLocator(node, .valueMember(node.memberName))))
  }

  func visit(_ node: QualDeclRefExpr) {
  }

  func visit(_ node: OverloadedDeclRefExpr) {
    precondition(node.declSet.count >= 1)
    gen.system.insertDisjuncConf(disjunctionOfConstraintsWithWeights: node.declSet.map({ decl in
      let constraint = EqualityConstraint(
        node.type, isEqualTo: decl.type,
        at: ConstraintLocator(node))
      return (constraint, 0)
    }))
  }

  func visit(_ node: DeclRefExpr) {
  }

  func visit(_ node: TypeDeclRefExpr) {
  }

  func visit(_ node: MemberRefExpr) {
  }

  func visit(_ node: AddrOfExpr) {
  }

  func visit(_ node: WildcardExpr) {
  }

}
