import AST
import Basic

/// Val's type checker.
///
/// This class is the entry point to Val's type checker, whose goal is to verifies that program
/// sources satisfy Val's (flow-insensitive) static type system. It walks an untyped AST (typically
/// produced by the parser) and annotates it with the type information.
///
/// Conceptually, type checking is a composition of phases:
/// - **Extension binding**
///   Binds extensions to the declaration they extend.
/// - **Conformance enumeration**
///   Initializes the view conformance set of all nominal types. This includes enumerating
///   inherited and synthetized conformances.
/// - **Existential realization**
///   Realizes existential types from generic type signatures.
/// - **Name resolution**
///   Resolves declaration references.
/// - **Semantic type checking**
///   Checks that a particular declaration satisfies Val's type system.
///
/// These phases cannot be performed completely sequentially; some operations require results from
/// a "later" phase. For instance, binding the extension of a member type requires to run name
/// resolution over a qualified type reference (e.g., `Foo::Bar`). To address this problem, the
/// process is performed lazily so that not all AST nodes need to be brought up to a particular
/// phase at the same time.
///
/// The "phase" at which a node sits is encoded by the node itself, either explicitly within its
/// properties or by its very type (e.g., name resolution substitutes `DeclRefExpr`s for
/// `UnresolvedDeclRefExpr`s).
public final class TypeChecker {

  public init(context: AST.Context) {
    self.context = context
  }

  /// The context in which the pass runs.
  public unowned let context: AST.Context

  /// Type checks the given module.
  ///
  /// This goes through all top-level declarations in the module and type checks them,annotating
  /// AST nodes with typing information in the process. Error are reported through the context's
  /// diagnostic consumers
  ///
  /// - Parameter module: A module.
  public func check(module: Module) {
    // Generate type constraints
    let generator = CSGenDriver(checker: self)
    _ = generator.visit(module)

    // Sort the constraint system so that simpler constraints appear first.
    system.sort()

    // Solve the constraint system.
    var solver = CSSolver(
      system: system,
      assumptions: SubstitutionTable(),
      penalities: 0,
      bestScore: .worst,
      context: context)
    let solution = solver.solve()

    // Report type errors.
    let reifier = TypeReifier(substitutions: solution.assumptions.flattened())
    let reporter = TypeErrorReporter(context: context, reifier: reifier)
    reporter.report(solution.errors)

    // Apply the solution.
    let dispatcher = TypeDispatcher(reifier: reifier)
    _ = dispatcher.visit(module)
  }

  // MARK: Internal API

  /// The constraint system generated by the pass.
  var system = ConstraintSystem()

  /// A key in the existential lookup table.
  typealias ExistentialKey = HashableBox<ValType, ReferenceHashWitness<ValType>>

  /// A lookup table that keep tracks of the existential types that have been created.
  var existentials: [ExistentialKey: ExistentialType] = [:]

  /// Realizes the semantic type expressed by a representation.
  ///
  /// A type representation can denote either  three kinds of types:
  /// - A fully concrete type. This denotes either a non-generic type (e.g., `Int`) or a generic
  ///   type that has been specialized (e.g., `Array<Int>`). In this case, the semantic type is
  ///   fully known and the method just returns the type to which the representation resolves.
  /// - An unspecialized generic type (e.g., `Array` without any specialization clause). This
  ///   requires to "open" the type to which the representation resolves (i.e., substitute its
  ///   generic parameters for fresh variables).
  /// - An existential type (e.g., `T` within the context of `fun foo<T>`). This denotes a type
  ///   that is not known statically, but for which we may assume some conformances.
  func instanciate(_ type: ValType) -> ValType {
    if let param = type as? GenericParamType {
      // FIXME: A lot of magic will have to happen here to handle associated and dependent types.
      if let existential = existentials[HashableBox(param)] {
        return existential
      }

      let existential = context.existentialType()
      existentials[HashableBox(param)] = existential
      return existential
    }

    if type.props.contains(.hasTypeParams) {
      return type.opened
    }

    return type
  }

}
