import AST

/// Val's type checker.
///
/// This class is the entry point to Val's type checker, whose goal is to verifies that program
/// sources satisfy Val's (flow-insensitive) static type system. It walks an untyped AST (typically
/// produced by the parser) and annotates it with the type information.
///
/// Conceptually, type checking is a composition of phases:
/// - **Extension binding**
///   Binds extensions to the declaration they extend.
/// - **Conformance enumeration**
///   Initializes the view conformance set of all nominal types. This includes enumerating
///   inherited and synthetized conformances.
/// - **Existential realization**
///   Realizes existential types from generic type signatures.
/// - **Name resolution**
///   Resolves declaration references.
/// - **Semantic type checking**
///   Checks that a particular declaration satisfies Val's type system.
///
/// These phases cannot be performed completely sequentially; some operations require results from
/// a "later" phase. For instance, binding the extension of a member type requires to run name
/// resolution over a qualified type reference (e.g., `Foo::Bar`). To address this problem, the
/// process is performed lazily so that not all AST nodes need to be brought up to a particular
/// phase at the same time.
///
/// The "phase" at which a node sits is encoded by the node itself, either explicitly within its
/// properties or by its very type (e.g., name resolution substitutes `DeclRefExpr`s for
/// `UnresolvedDeclRefExpr`s).
public final class TypeChecker {

  public init(context: AST.Context) {
    self.context = context
  }

  /// The context in which the pass runs.
  public unowned let context: AST.Context

  /// Type checks the given module.
  ///
  /// This goes through all top-level declarations in the module and type checks them,annotating
  /// AST nodes with typing information in the process. Error are reported through the context's
  /// diagnostic consumers
  ///
  /// - Parameter module: A module.
  public func check(module: Module) {
    // Generate type constraints
    let generator = CSGenDriver(checker: self)
    _ = generator.visit(module)

    // Sort the constraint system so that simpler constraints appear first.
    system.sort()
    for constraint in system.freshConstraints {
      print(constraint)
    }

    // Solve the constraint system.
    var solver = CSSolver(
      system: system,
      assumptions: SubstitutionTable(),
      penalities: 0,
      bestScore: .worst,
      context: context)
    let solution = solver.solve()

    // Report type errors.
    let reporter = TypeErrorReporter(context: context, solution: solution)
    reporter.report(solution.errors)

    // Apply the solution.
    let dispatcher = TypeDispatcher(solution: solution)
    _ = dispatcher.visit(module)
  }

  // MARK: Internal API

  /// The constraint system generated by the pass.
  var system = ConstraintSystem()

  static func match(_ decl: TypeOrValueDecl, _ type: ValType, useSite: DeclSpace) -> Bool {
    let declType: ValType
    if let valueDecl = decl as? ValueDecl {
      declType = valueDecl.instantiate(from: useSite)
    } else {
      assert(!(decl.type is UnresolvedType), "declaration has not been realized")
      declType = decl.type
    }

    if let inoutType = declType as? InoutType {
     return inoutType.base == type
    }
    return declType == type
  }

}
