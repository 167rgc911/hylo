// TODO: Equatable, Comparable

// A regular type (per Stepanov).
public trait Regular: Deinitializable, Copyable, Movable {}

/// A typed memory address whose contents can be read.
public type Pointer<Pointee>: Regular {

  /// The raw bits of the address.
  var base: Builtin.ptr

  memberwise init

  public fun copy() -> Self {
    Pointer(base: base)
  }

  /// The value at the given address.
  ///
  /// - Requires: the address stores an object of type Pointee and nothing modifies
  ///   that storage during the lifetime of this projection.
  public subscript unsafe(): Pointee {
    yield base as* (remote let Pointee)
  }

  /// Creates an instance referring to the same address as `p`.
  public init(_ p: MutatingPointer<Pointee>) {
    &base = p.base
  }

}

/// A typed memory address whose contents can be read and written.
public type MutatingPointer<Pointee>: Regular {

  /// The raw bits of the address.
  var base: Builtin.ptr

  memberwise init

  /// Returns an equivalent instance.
  ///
  /// Because we don't have a `nonmutating` keyword yet, writing to the pointee of a `let`-bound
  /// `MutatingPointer` is only possible by copying, e.g.  `&p.copy().unsafe[] = x`.
  public fun copy() -> Self {
    MutatingPointer(base: base)
  }

  /// The value at the given address.
  ///
  /// - Requires: the address stores a mutable object of type Pointee and nothing accesses that
  ///   storage except through this projection during its lifetime.
  public subscript unsafe(): Pointee {
    let { yield base as* (remote let Pointee) }
    inout { yield &(base as* (remote let Pointee)) }
  }

  /// Creates an instance with mutable access to the memory pointed to by `p`.
  ///
  /// - Warning: while this initializer is not in itself unsafe, it should be used with caution.
  public init(adding_mutation_to p: Pointer<Pointee>) {
    &base = p.base
  }

}

extension Int {

  fun infix+= (_ other: Int) {
    &self = self + other
  }

}

public conformance Pointer: ForeignConvertible {

  public typealias ForeignRepresentation = Builtin.ptr

  public init(foreign_value: sink Builtin.ptr) {
    &self.base = foreign_value
  }

  public fun foreign_value() -> Builtin.ptr {
    base
  }

}

public conformance MutatingPointer: ForeignConvertible {

  public typealias ForeignRepresentation = Builtin.ptr

  public init(foreign_value: sink Builtin.ptr) {
    &self.base = foreign_value
  }

  public fun foreign_value() -> Builtin.ptr {
    base
  }

}

fun test(p: Pointer<Int>, m: MutatingPointer<Int>) {
  var x: Int = p.unsafe[].copy()
  x += m.unsafe[]
  var m1 = m.copy()
  m1.unsafe[] += x
  m1.unsafe[] += p.unsafe[]
}

public fun main() {}
